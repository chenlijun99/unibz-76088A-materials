
@inproceedings{adyaCooperativeTaskManagement2002,
  title = {Cooperative {{Task Management Without Manual Stack Management}}},
  author = {Adya, Atul and Howell, Jon and Theimer, Marvin and Bolosky, Bill and Douceur, John},
  date = {2002},
  url = {https://www.usenix.org/conference/2002-usenix-annual-technical-conference/cooperative-task-management-without-manual-stack},
  urldate = {2022-02-21},
  eventtitle = {2002 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 02)},
  langid = {english},
  file = {/home/lijun/pCloudDrive/Zotero/Adya et al_2002_Cooperative Task Management Without Manual Stack Management.pdf}
}

@book{erichDesignPatternsElements1994,
  title = {Design Patterns: Elements of Reusable Object-Oriented Software},
  shorttitle = {Design Patterns},
  author = {Erich, Gamma and Richard, Helm and Ralph, Johnson and John, Vlissides and Booch, Grady},
  date = {1994-10-31},
  publisher = {{Addison-Wesley Professional}},
  abstract = {Capturing a wealth of experience about the design of object-oriented software, four top-notch designers present a catalog of simple and succinct solutions to commonly occurring design problems. Previously undocumented, these 23 patterns allow designers to create more flexible, elegant, and ultimately reusable designs without having to rediscover the design solutions themselves.  The authors begin by describing what patterns are and how they can help you design object-oriented software. They then go on to systematically name, explain, evaluate, and catalog recurring designs in object-oriented systems. With Design Patterns as your guide, you will learn how these important patterns fit into the software development process, and how you can leverage them to solve your own design problems most efficiently.   Each pattern describes the circumstances in which it is applicable, when it can be applied in view of other design constraints, and the consequences and trade-offs of using the pattern within a larger design. All patterns are compiled from real systems and are based on real-world examples. Each pattern also includes code that demonstrates how it may be implemented in object-oriented programming languages like C++ or Smalltalk.},
  langid = {Inglese},
  pagetotal = {568},
  file = {/home/lijun/pCloudDrive/Zotero/Erich et al_1994_Design Patterns.pdf}
}

@article{harelStatechartsVisualFormalism1987,
  title = {Statecharts: A Visual Formalism for Complex Systems},
  shorttitle = {Statecharts},
  author = {Harel, David},
  date = {1987-06-01},
  journaltitle = {Science of Computer Programming},
  shortjournal = {Science of Computer Programming},
  volume = {8},
  number = {3},
  pages = {231--274},
  issn = {0167-6423},
  doi = {10.1016/0167-6423(87)90035-9},
  url = {https://www.sciencedirect.com/science/article/pii/0167642387900359},
  urldate = {2022-02-18},
  abstract = {We present a broad extension of the conventional formalism of state machines and state diagrams, that is relevant to the specification and design of complex discrete-event systems, such as multi-computer real-time systems, communication protocols and digital control units. Our diagrams, which we call statecharts, extend conventional state-transition diagrams with essentially three elements, dealing, respectively, with the notions of hierarchy, concurrency and communication. These transform the language of state diagrams into a highly structured and economical description language. Statecharts are thus compact and expressive—small diagrams can express complex behavior—as well as compositional and modular. When coupled with the capabilities of computerized graphics, statecharts enable viewing the description at different levels of detail, and make even very large specifications manageable and comprehensible. In fact, we intend to demonstrate here that statecharts counter many of the objections raised against conventional state diagrams, and thus appear to render specification by diagrams an attractive and plausible approach. Statecharts can be used either as a stand-alone behavioral description or as part of a more general design methodology that deals also with the system's other aspects, such as functional decomposition and data-flow specification. We also discuss some practical experience that was gained over the last three years in applying the statechart formalism to the specification of a particularly complex system.},
  langid = {english},
  file = {/home/lijun/pCloudDrive/Zotero/Harel_1987_Statecharts.pdf;/home/lijun/Zotero/storage/8EA2CX64/0167642387900359.html}
}

@online{hitoyoshiHaskellersThoughtsStatecharts2020,
  type = {Reddit Post},
  title = {Haskellers Thoughts on Statecharts},
  author = {{hitoyoshi}},
  date = {2020-05-21T10:18:24},
  url = {www.reddit.com/r/haskell/comments/gnu956/haskellers_thoughts_on_statecharts/},
  urldate = {2022-02-19},
  organization = {{r/haskell}}
}

@book{kernighanProgrammingLanguageANSI1988,
  title = {The C Programming Language: ANSI C Version},
  shorttitle = {The C Programming Language},
  author = {Kernighan, Brian W.},
  date = {1988-03-22},
  publisher = {{Pearson College Div}},
  location = {{Englewood Cliffs, N.J}},
  abstract = {Introduces the features of the C programming language, discusses data types, variables, operators, control flow, functions, pointers, arrays, and structures, and looks at the UNIX system interface},
  isbn = {978-0-13-110362-7},
  langid = {Inglese},
  pagetotal = {274},
  file = {/home/lijun/pCloudDrive/Zotero/Kernighan_1988_The C Programming Language.pdf}
}

@article{lavenderActiveObjectObject1996,
  title = {Active Object: An Object Behavioral Pattern for Concurrent Programming},
  shorttitle = {Active Object},
  author = {Lavender, R. G. and Schmidt, D.},
  date = {1996},
  journaltitle = {undefined},
  url = {https://www.semanticscholar.org/paper/Active-object%3A-an-object-behavioral-pattern-for-Lavender-Schmidt/161fd1df0ceb45acf68a8dd1293d295ba77082cf},
  urldate = {2022-02-06},
  abstract = {The Active Object pattern is described, which decouples method execution from method invocation in order to simplify synchronized access to an object that resides in its own thread of control. This paper describes the Active Object pattern, which decouples method execution from method invocation in order to simplify synchronized access to an object that resides in its own thread of control. The Active Object pattern allows one or more independent threads of execution to interleave their access to data modeled as a single object. A broad class of producer/consumer and reader/writer applications are wellsuited to this model of concurrency. This pattern is commonly used in distributed systems requiring multi-threaded servers. In addition, client applications, such as windowing systems and network browsers, employ active objects to simplify concurrent, asynchronous network operations.},
  langid = {english},
  file = {/home/lijun/pCloudDrive/Zotero/Lavender_Schmidt_1996_Active object.pdf}
}

@online{LeiSiYuSTM32ZhiLeiDeDanPianJiRTOSBiLuoBenBianChengLuoJi,
  title = {{{类似于STM32之类的单片机}}，{{RTOS比裸奔编程}}（裸机/裸跑）真有那么大优势？},
  url = {https://www.zhihu.com/question/438040639/answer/1796389613}
}

@book{lindenExpertProgrammingDeep1994,
  title = {Expert C Programming: Deep C Secrets},
  shorttitle = {Expert C Programming},
  author = {Linden, Peter Van Der},
  date = {1994},
  edition = {1° edizione},
  publisher = {{Prentice Hall}},
  location = {{Mountain View, Cal.}},
  isbn = {978-0-13-177429-2},
  langid = {Inglese},
  pagetotal = {384},
  file = {/home/lijun/pCloudDrive/Zotero/Linden_1994_Expert C Programming.pdf}
}

@book{marwedelEmbeddedSystemDesign2018,
  title = {Embedded {{System Design}}: {{Embedded Systems Foundations}} of {{Cyber-Physical Systems}}, and the {{Internet}} of {{Things}}},
  shorttitle = {Embedded {{System Design}}},
  author = {Marwedel, Peter},
  date = {2018-05-13},
  abstract = {A unique feature of this textbook is to provide a comprehensive introduction to the fundamental knowledge in embedded systems, with applications in cyber-physical systems and the Internet of things. It starts with an introduction to the field and a survey of specification models and languages for embedded and cyber-physical systems. It provides a brief overview of hardware devices used for such systems and presents the essentials of system software for embedded systems, including real-time operating systems. The author also discusses evaluation and validation techniques for embedded systems and provides an overview of techniques for mapping applications to execution platforms, including multi-core platforms. Embedded systems have to operate under tight constraints and, hence, the book also contains a selected set of optimization techniques, including software optimization techniques. The book closes with a brief survey on testing. This third edition has been updated and revised to reflect new trends and technologies, such as the importance of cyber-physical systems and the Internet of things, the evolution of single-core processors to multi-core processors, and the increased importance of energy efficiency and thermal issues.},
  file = {/home/lijun/pCloudDrive/Zotero/Marwedel_2018_Embedded System Design.pdf}
}

@online{MemoryModelCppreference,
  title = {Memory Model - Cppreference.Com},
  url = {https://en.cppreference.com/w/c/language/memory_model},
  urldate = {2022-03-15}
}

@article{pyaraliObjectBehavioralPattern1998,
  title = {An {{Object Behavioral Pattern}} for {{Demultiplexing}} and {{Dispatching Handlers}} for {{Asynchronous Events}}},
  author = {Pyarali, I. and Harrison, T. and Schmidt, D. and Jordan, T. D.},
  date = {1998},
  journaltitle = {undefined},
  url = {https://www.semanticscholar.org/paper/An-Object-Behavioral-Pattern-for-Demultiplexing-and-Pyarali-Harrison/3921e03e2913b237380240dd9426b16fabf07afb},
  urldate = {2022-02-06},
  abstract = {The Proactor pattern simplifies concurrent programming and improves performance by requiring fewer threads and leveraging OS support for asynchronous operations. Modern operating systems provide multiple mechanisms for developing concurrent applications. Synchronous multithreading is a popular mechanism for developing applications that perform multiple operations simultaneously. However, threads often have high performance overhead and require deep knowledge of synchronization patterns and principles. Therefore, an increasing number of operating systems support asynchronous mechanisms that provide the benefits of concurrency while alleviating much of the overhead and complexity of multi-threading. The Proactor pattern presented in this paper describes how to structure applications and systems that effectively utilize asynchronous mechanisms supported by operating systems. When an application invokes an asynchronous operation, the OS performs the operation on behalf of the application. This allows the application to have multiple operations running simultaneously without requiring the application to have a corresponding number of threads. Therefore, the Proactor pattern simplifies concurrent programming and improves performance by requiring fewer threads and leveraging OS support for asynchronous operations.},
  langid = {english},
  file = {/home/lijun/pCloudDrive/Zotero/Pyarali et al_1998_An Object Behavioral Pattern for Demultiplexing and Dispatching Handlers for.pdf}
}

@online{regehrNineWaysBreak2010,
  title = {Nine Ways to Break Your Systems Code Using Volatile – {{Embedded}} in {{Academia}}},
  author = {Regehr, John},
  date = {2010-02-26},
  url = {https://blog.regehr.org/archives/28},
  urldate = {2022-03-28},
  organization = {{Nine ways to break your systems code using volatile}}
}

@article{schmidtReactorObjectBehavioral1995,
  title = {Reactor {{An Object Behavioral Pattern}} for {{Demultiplexing}} and {{Dispatching Handles}} for {{Synchronous Events}}},
  author = {Schmidt, D.},
  date = {1995},
  journaltitle = {undefined},
  url = {https://www.semanticscholar.org/paper/Reactor-An-Object-Behavioral-Pattern-for-and-for-Schmidt/5b2d55303860cbaafc911c08a51f38c5c8f9580f},
  urldate = {2022-02-06},
  abstract = {The Reactor design pattern handles service requests that are delivered concurrently to an application by one or more clients. The Reactor design pattern handles service requests that are delivered concurrently to an application by one or more clients. Each service in an application may consist of serveral methods and is represented by a separate event handler that is responsible for dispatching service-specific requests. Dispatching of event handlers is performed by an initiation dispatcher, which manages the registered event handlers. Demultiplexing of service requests is performed by a synchronous event demultiplexer.},
  langid = {english},
  file = {/home/lijun/pCloudDrive/Zotero/Schmidt_1995_Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles.pdf}
}

@book{scottProfessionalCMakePractical,
  title = {Professional {{CMake}}: {{A Practical Guide}}},
  author = {Scott, Craig},
  langid = {english},
  file = {/home/lijun/pCloudDrive/Zotero/Scott_Professional CMake.pdf}
}

@book{van-royConceptsTechniquesModels2004,
  title = {Concepts, Techniques, and Models of Computer Programming},
  author = {Van-Roy, Peter and Haridi, Seif},
  date = {2004},
  publisher = {{MIT Press}},
  location = {{Cambridge, Mass}},
  isbn = {978-0-262-22069-9},
  langid = {english},
  pagetotal = {900},
  keywords = {Computer programming},
  file = {/home/lijun/pCloudDrive/Zotero/Van-Roy_Haridi_2004_Concepts, techniques, and models of computer programming.pdf}
}

@misc{wg14/n1256C99StandardDraft2007,
  title = {C99 Standard Draft},
  author = {WG14/N1256},
  date = {2007-09-07},
  file = {/home/lijun/pCloudDrive/Zotero/WG14N1256_2007_C99 standard draft.pdf}
}

@book{whiteMakingEmbeddedSystems2012,
  title = {Making Embedded Systems: Design Patterns for Great Software},
  shorttitle = {Making Embedded Systems},
  author = {White, Elecia},
  date = {2012},
  edition = {1. ed},
  publisher = {{O'Reilly}},
  location = {{Beijing}},
  isbn = {978-1-4493-0214-6},
  langid = {english},
  pagetotal = {310},
  annotation = {OCLC: 815881891},
  file = {/home/lijun/pCloudDrive/Zotero/White_2012_Making embedded systems.pdf}
}

@online{WhyVolatileType,
  title = {Why the “Volatile” Type Class Should Not Be Used — {{The Linux Kernel}} Documentation},
  url = {https://www.kernel.org/doc/html/latest/process/volatile-considered-harmful.html},
  urldate = {2022-03-31}
}

@book{wintersSoftwareEngineeringGoogle2020,
  title = {Software {{Engineering}} at {{Google}}: {{Lessons Learned}} from {{Programming Over Time}}},
  shorttitle = {Software {{Engineering}} at {{Google}}},
  author = {Winters, Titus and Manshreck, Tom and Wright, Hyrum},
  date = {2020-03-24},
  edition = {1st edition},
  publisher = {{O'Reilly Media}},
  location = {{Beijing Boston Farnham Sebastopol Tokyo}},
  isbn = {978-1-4920-8279-8},
  langid = {english},
  pagetotal = {602},
  file = {/home/lijun/pCloudDrive/Zotero/Winters et al_2020_Software Engineering at Google.pdf}
}


